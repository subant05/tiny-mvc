# Tiny MVC

The Tiny MVC allows you to create small MVC single page applications. 

## router()

The SPA built using the **router()** function

### Router accepts Two arguments

#### First Argument is the configuration object

takes object as its first argument. The object passed to the router is a configuration object, which uses applications routes as properties that each contain their own configuration object. Each object assigned to a route **MUST** contain the following properties:
* **template**
    * * This property accepts the relative path string to the html file that contains your view ( html code )
* **controller**
    * * This property accepts a class that used do the following:
    * * * Pass ${scope} values to the template
    * * * Add event handlers to nodes in the template using *onmounted()* 
    * * * Update state of the application

An optional property that can be added to the route configuration object is: 
* **service** 
    * * This property accepts a function, which is exectuted prior to the controller.
    * * * This service can be used to fetch any data or perform any tasks that are needed before the controller is executed and the template is loaded into the DOM.


#### Second Argument is the default route

Because this a SPA app needs to working within a server-side application, the second argument accepts the a string that represents the default route the app should use when performing redirects or update location state. If the second argument is not utilized, then the app will use "/" as the default router

Below is an example of how to use the router()

```javascript
router({
    "/users":{
        template: "/assets/templates/smallapp/users.html"
        , service: getAllUsersService
        , controller: UsersController
    }
    , "/users/user-edit":{
        template: "/assets/templates/smallapp/users-edit.html"
        , service: getUserService
        , controller: EditUserController
    }

    ...

},"/users")

```

## Template

When creating a template, be sure to place the templates in the template folder, located at 'src/AppFrontend/templates'. Templates should have a *.html* extension. The template can be created using regular HTML. To create placeholders, where load dynamic data into the template from the controller, use template literal syntax with _*scope*_ being the reference to the _*this*_ object from the controller.

Below is an example of a template
```html
    <h1>${scope.title}</h1>
    <ul>
        <li>${scope.userA}</li>
        <li>${scope.userB}</li>
        <li>${scope.userC}</li>
    </ul>
```

**NOTE** 
Functions, loops or any form of exections are not available within the templates currently. This maybe added in the future.

## Controller

The controller describles exactly what it does in reference to the template. It controls the data passed to the template and handles all events from nodes that were generated by the template. Controller is also where you handle the applications business logic.

The controller extends the RouterController which includes framework methods such as *routerRedirect()*, *onmounted()* and *onunmouted()*.  The RouterController can be imported from the 'components/router/router.js' file.

### RouterController Methods 

There are a few methods that are a controller inherits from the RouterController class.

* **routerRedirect()**
* * This method takes a string representing a route/path and will redirect the user to that specific path/page
* **onmounted()**
* * This method takes a callback as an argument and framework will execute that callback when the page has been rendered/mounted to the DOM. You can use this callback to add event listeners to the nodes that have been rendered into the page and execute any logic that you want to occur as soon as the template is rendered.
* **onunmounted()**
* * This method works on the same premise as onmounted() except that it is executed after the template/view has been removed from the viewport and before the new template/view for another route is loaded into the viewport. This method allows you to add a callback that can handle clean up or perform some logic before the user leaves the "page"

### 2 constructor arguments

The controller constructor accepts 2 arguments. The first arguement is an object that has been provided by a service that was executed prior to the constrollers instantiation. This data can be utilized by the controller.

The second argument is the a state object.  This state is passed around between controllers and therefore data can be shared amongst the controllers using this state object.

Also note, that once a route is executed, that route is added to the state as a property which contains an object. You have the option to updated the objects associated with a route or simply add or remove properties from the state within your controller.



Below is an example of a controller:
```javascript
    class UserController extends RouterController{
        constructor(data={}, state={}){
            super(data={}, state={})

            this.state = state
            this.title = "Users List"
            this.userA = data.userA
            this.userB = data.userB
            this.userC = data.userC

            this.onmounted(()=>{
                document
                .getElementByTagName("ul")[0]
                .addEventListener(
                    "click"
                    , e=>this.listHandler(e)
                    , false
                )
            })

            this.onunmounted(()=>{
                this.state["/users"].didUserLeave = "User Left The Users List Page."
                alert("Goodbye")
            })
        }

        listHandler(e){
            alert(e.target.innerText)
            this.routerRedirect("user-edit")
        }
    }
```

## Service

As stated before, this is a function, which is exectuted prior to the controller. This function _SHOULD_ be asynchronous and be used to fetch data from a web service that is need inorder for the associated controller to exectute properly.

Below is an example of a service:
```javascript
async function getAllUsersService (){
    return new Promise((resolve, reject)=>{
        $.ajax({
            method:"get",
            url: "/api/users",
        }).done(response=>{
            resolve(response)
        }).fail(err=>{
            reject(err)
        })
    })
}
```
